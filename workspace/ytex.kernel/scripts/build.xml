<!--
-->
<project name="ytex.kernel">
	<property environment="env" />
	<property name="ytex.home" value="../.." />
	<property name="config.local" value="${ytex.home}/config/desc" />
	<property name="ytex.properties" value="${config.local}/ytex.properties" />
	<property file="${ytex.properties}" />

	<path id="kernel.cp.dev">
		<pathelement location="${config.local}" />
		<pathelement location="${ytex.home}/config/desc" />
		<pathelement location="${ytex.home}/cmc/bin" />
		<pathelement location="${ytex.home}/ytex.kernel/bin" />
		<pathelement location="${ytex.home}/ytex.model/bin" />
		<fileset dir="${ytex.home}/libs.system" includes="**/*.jar" />
		<fileset dir="${ytex.home}/ytex.web/WebContent/WEB-INF/lib" includes="**/*.jar" />
	</path>
	<path id="kernel.cp.prod">
		<pathelement location="${config.local}" />
		<pathelement location="${ytex.home}/config/desc" />
		<fileset dir="${ytex.home}/lib" includes="**/*.jar" />
		<fileset dir="${ytex.home}/web/webapps/ytex.web/WEB-INF/lib" includes="**/*.jar" />
	</path>
	<property name="kernel.cp" value="kernel.cp.prod" />
	<!-- 
	for some reason on linux just copying the jars to the ant/lib directory doesn't work.
	explicitly define the task.
	-->
	<taskdef name="for" classname="net.sf.antcontrib.logic.ForTask" onerror="ignore" classpathref="${kernel.cp}" />
	<taskdef name="if" classname="net.sf.antcontrib.logic.IfTask" onerror="ignore" classpathref="${kernel.cp}" />

	<target name="cv.iter.experiment" description="iterate over ${kernel.dirs} in ${kernel.exp.base}">
		<echo>kernel.exp.base ${kernel.exp.base}</echo>
		<echo>kernel.dirs ${kernel.dirs}</echo>
		<for param="kernel.data">
			<dirset dir="${kernel.exp.base}" includes="${kernel.dirs}" />
			<sequential>
				<antcall target="cv.process.dir">
					<param name="kernel.data" value="@{kernel.data}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="cv.init.dir" description="initialize variables for experiment from ${kernel.data}/kernel.properties">
		<fail unless="kernel.data" />
		<property file="${kernel.data}/kernel.properties" />
		<property file="${basedir}/kernel-default.properties" />
		<makeurl property="log4j.url" file="${ytex.home}/config/desc/log4j.properties" />
		<property name="log4j.arg" value="-Dlog4j.configuration=${log4j}" />
		<property name="java.log.arg" value="-Djava.util.logging.config.file=${ytex.home}/config/desc/Logger.properties" />
		<!-- set flags to control which evaluation to perform -->
		<condition property="svmlight">
			<equals arg1="${kernel.algo}" arg2="svmlight" />
		</condition>
		<condition property="libsvm">
			<equals arg1="${kernel.algo}" arg2="libsvm" />
		</condition>
		<condition property="semil">
			<equals arg1="${kernel.algo}" arg2="semil" />
		</condition>
		<!-- set flags to control which machine learning target to run on each fold -->
		<condition property="cv.process.dir.target" value="cv.semil.process.dir" else="cv.svm.process.dir">
			<isset property="semil" />
		</condition>
		<property name="cv.kernel.tmpdir" value="${cv.tmpdir}/${kernel.name}-${kernel.experiment}-${kernel.algo}${kernel.param1}${kernel.param2}" />
	</target>
	<target name="cv.process.dir" description="run cross validation on directory kernel.data" depends="cv.init.dir">
		<antcall target="${cv.process.dir.target}" />
	</target>
	<target name="cv.svm.process.dir" description="iterate over ${kernel.data}/*train_data.txt, evaluate svm.  call cv.svm.processFold" depends="cv.init.dir">
		<echo>kernel.data ${kernel.data}</echo>
		<!-- iterate over files -->
		<for param="training.file" parallel="${parallel.folds}" threadCount="${kernel.threads}">
			<fileset dir="${kernel.data}" includes="*train_data.txt" />
			<sequential>
				<antcall target="cv.svm.processFold">
					<param name="kernel.train.data" value="@{training.file}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="cv.svm.processFold" depends="cv.init.dir" description="iterate over parameter grid and run svm on specified fold, store results in database. call cv.iter.kernel">
		<property name="kernel.train.data" value="${kernel.data}/label1_run1_fold1_train_data.txt" />
		<basename file="${kernel.train.data}" property="kernel.data.basename.prefix1" suffix="train_data.txt" />
		<basename file="${kernel.data.basename.prefix1}" property="kernel.data.basename" suffix="_" />
		<property name="kernel.workdir" value="${cv.kernel.tmpdir}-${kernel.data.basename}" />
		<echo>kernel.data.basename ${kernel.data.basename}</echo>
		<echo>kernel.workdir ${kernel.workdir}</echo>
		<mkdir dir="${kernel.workdir}" />
		<copy todir="${kernel.workdir}">
			<fileset dir="${kernel.data}" includes="${kernel.data.basename}*.*" />
		</copy>
		<antcall target="cv.svm.iter.kernel" />
		<antcall target="eval.store.db" />
		<!-- cleanup -->
		<mkdir dir="${kernel.data}/cv" />
		<zip destfile="${kernel.data}/cv/${kernel.data.basename}.zip" update="yes">
			<fileset dir="${kernel.workdir}" excludes="*.*" />
		</zip>
		<delete quiet="yes" includeemptydirs="yes" dir="${kernel.workdir}" />
	</target>
	<target name="cv.svm.iter.kernel" description="run cross-validation with all specified kernels, delegate to cv.iter.weight">
		<for list="${kernel.types}" param="kernel.type">
			<sequential>
				<echo>kernel.type = @{kernel.type}</echo>
				<antcall target="cv.svm.iter.weight">
					<param name="kernel.type" value="@{kernel.type}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="cv.svm.init.classWeights" description="load property with class weights to iterate over for the given class label">
		<property name="kernel.label" value="0" />
		<echo>kernel.classweights=${kernel.classweights}</echo>
		<echo>kernel.label=${kernel.label}</echo>
		<if>
			<and>
				<available file="${kernel.classweights}" />
				<equals arg1="${kernel.algo}" arg2="libsvm" />
			</and>
			<then>
				<loadfile srcfile="${kernel.classweights}" property="classWeights">
					<filterchain>
						<linecontains>
							<contains value="class.weight.${kernel.label}=" />
						</linecontains>
						<replacestring from="class.weight.${kernel.label}=" to="" />
						<striplinebreaks />
					</filterchain>
				</loadfile>
			</then>
		</if>
		<echo>classWeights=${classWeights}</echo>
		<!-- for precomputed gram matrix or linear kernel, iterate over cost params -->
		<echo>kernel.type = ${kernel.type}</echo>
		<condition property="cv.svm.iter.target" value="cv.svm.iter.cost">
			<or>
				<equals arg1="${kernel.type}" arg2="4" />
				<equals arg1="${kernel.type}" arg2="0" />
			</or>
		</condition>
		<!-- for polynomial kernel, iterate over degrees -->
		<condition property="cv.svm.iter.target" value="cv.svm.iter.degree">
			<equals arg1="${kernel.type}" arg2="1" />
		</condition>
		<!-- for rbg/sigmoid iterate over gamma -->
		<condition property="cv.svm.iter.target" value="cv.svm.iter.gamma">
			<or>
				<equals arg1="${kernel.type}" arg2="2" />
				<equals arg1="${kernel.type}" arg2="3" />
			</or>
		</condition>
	</target>
	<target name="cv.svm.iter.weight" depends="cv.svm.init.classWeights" description="iterate over class weights">
		<if>
			<isset property="classWeights" />
			<then>
				<for list="${classWeights}" param="classWeight">
					<sequential>
						<echo>classWeight = @{classWeight}</echo>
						<antcall target="${cv.svm.iter.target}">
							<param name="cv.weight" value="@{classWeight}" />
							<param name="cv.kernel.line" value="@{classWeight}" />
						</antcall>
					</sequential>
				</for>
			</then>
			<else>
				<antcall target="${cv.svm.iter.target}">
					<param name="cv.kernel.line" value="" />
				</antcall>
			</else>
		</if>
	</target>
	<target name="cv.svm.iter.degree" description="iterate polynomial kernel degree, delegate to cv.iter.cost">
		<for list="${cv.poly.degrees}" param="degree">
			<sequential>
				<antcall target="cv.svm.iter.cost">
					<param name="cv.degree" value="@{degree}" />
					<param name="cv.kernel.line" value="${cv.kernel.line} -d @{degree}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="cv.svm.iter.gamma" description="iterate rbg kernel gamma, delegate to cv.iter.cost">
		<for list="${cv.rbf.gammas}" param="gamma">
			<sequential>
				<antcall target="cv.svm.iter.cost">
					<param name="cv.gamma" value="@{gamma}" />
					<param name="cv.kernel.line" value="${cv.kernel.line} -g @{gamma}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="cv.svm.iter.cost" description="iterate over cost parameters, delegate to cv.evaluate">
		<for list="${cv.costs}" param="cost">
			<sequential>
				<antcall target="cv.svm.evaluate">
					<param name="cv.cost" value="@{cost}" />
					<param name="cv.kernel.line" value="${cv.kernel.line} -c @{cost}" />
				</antcall>
			</sequential>
		</for>
	</target>

	<target name="cv.svm.evaluate.init">
		<!-- want to put each result in a different directory, use timestamp, but libsvm is fast -->
		<sleep milliseconds="10" />
		<tstamp>
			<format property="cv.tstamp" pattern="dd-hh-mm-s.S" />
		</tstamp>
		<property name="kernel.outdir" value="${cv.tstamp}" />
		<mkdir dir="${kernel.workdir}/${kernel.outdir}" />
		<property name="kernel.label" value="1" />
		<property name="kernel.data.basename" value="label${kernel.label}_run1_fold1" />
		<property name="kernel.train.data" value="${kernel.data.basename}_train_data.txt" />
		<property name="kernel.test.data" value="${kernel.data.basename}_test_data.txt" />
	</target>

	<target name="cv.svm.evaluate" depends="cv.svm.evaluate.init" description="call libsvm/svmlight">
		<antcall target="evaluate.svmlight" />
		<antcall target="evaluate.libsvm" />
	</target>

	<target name="evaluate.svmlight" if="svmlight" description="call svmlight">
		<!-- train the svm -->
		<property name="kernel.train.line" value="-t ${kernel.type} -l ${kernel.outdir}/transduct.txt ${cv.kernel.line} ${kernel.train.data} ${kernel.outdir}/model.txt" />
		<exec executable="${svmlight.bin}/svm_learn" dir="${kernel.workdir}" failonerror="no" output="${label.dir}/${kernel.outdir}/output.txt" timeout="${kernel.timeout}">
			<arg line="${kernel.train.line}" />
		</exec>
		<!-- test the svm -->
		<exec executable="${svmlight.bin}/svm_classify" dir="${kernel.workdir}" failonerror="no" timeout="${kernel.timeout}">
			<arg line="${kernel.test.data} ${kernel.outdir}/model.txt ${kernel.outdir}/predict.txt" />
		</exec>
		<antcall target="eval.store.options" />
	</target>

	<target name="evaluate.libsvm" if="libsvm" description="train on cv training set, eval on cv test set, store results in fold-specific timestamped directory">
		<!-- train the svm -->
		<property name="kernel.train.line" value="-q -b 1 -t ${kernel.type} ${cv.kernel.line} ${kernel.train.data} ${kernel.outdir}/model.txt" />
		<exec executable="${libsvm.bin}/svm-train" dir="${kernel.workdir}" failonerror="yes">
			<arg line="${kernel.train.line}" />
		</exec>
		<!-- test the svm -->
		<exec executable="${libsvm.bin}/svm-predict" dir="${kernel.workdir}" failonerror="yes">
			<arg line="-b 1 ${kernel.test.data} ${kernel.outdir}/model.txt ${kernel.outdir}/predict.txt" />
		</exec>
		<antcall target="eval.store.options" />
	</target>
	<!--
	semil targets:
	cv.semil.iter.dir - generate distance matrices, evaluate semil for all files, calls cv.semil.iter
	cv.semil.iter - iterate over degree, metric, *data.txt, call either semil.dist or cv.semil.evaluate
	semil.dist - generate distance matrix by calling R script
	cv.semil.evaluate - iterate over methods (grf/cm), gamma, and label.txt and evaluate semil
	-->
	<target name="semil.process.dir" depends="cv.init.dir,semil.createDistances,cv.semil.genParams,semil.evaluate,semil.storeResults" description="generate distance matrices, run semil" />
	<target name="cv.semil.genParams" depends="cv.init.dir" unless="no.semil.genParams">
		<propertyset id="kernel.props">
			<propertyref prefix="kernel." />
		</propertyset>
		<propertyset id="cv.props">
			<propertyref prefix="cv." />
		</propertyset>
		<java classname="ytex.kernel.ClassifierEvalUtil" classpathref="${kernel.cp}">
			<syspropertyset>
				<propertyset refid="cv.props" />
				<propertyset refid="kernel.props" />
			</syspropertyset>
		</java>
	</target>
	<target name="semil.createDistances" depends="cv.init.dir">
		<for param="kernel.data.file">
			<fileset dir="${kernel.data}" includes="*data.txt" />
			<sequential>
				<antcall target="semil.createDistance">
					<param name="kernel.data.file" value="@{kernel.data.file}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="semil.createDistance" description="generate distance matrix by calling semil_dist.R script">
		<!--
		semil distance computation will not work on windows
		requires interactive shell - otherwise fails
		created R script to generate distance matrix
		
		default to cross-validation settings.
		this can be overridden by eval.properties
		-->
		<echo>kernel.data.file ${kernel.data.file}</echo>
		<property name="kernel.data.file" value="./label1_data.txt" />
		<!-- strip off the directory -->
		<basename file="${kernel.data.file}" property="kernel.data.file.name" />
		<!-- strip off the data.txt prefix - this is the prefix for the distance file -->
		<basename file="${kernel.data.file.name}" property="kernel.basename" suffix="data.txt" />
		<!-- load label.properties file - can override default cv.semil.metrics and cv.semil.degrees there -->
		<property file="${kernel.data}/${kernel.basename}label.properties" />
		<property name="semil.metrics" value="${cv.semil.metrics}" />
		<property name="semil.degrees" value="${cv.semil.degrees}" />
		<echo>semil.metrics ${semil.metrics}</echo>
		<echo>semil.degrees ${semil.degrees}</echo>
		<mkdir dir="${kernel.dist.dir}" />
		<exec executable="${R.bin}/R" dir="${kernel.data}">
			<arg line="--slave --file=${basedir}/semil_dist.R --args ${kernel.data.file} ${semil.metrics} ${kernel.basename} ${semil.degrees}" />
		</exec>
	</target>
	<target name="semil.evaluate" depends="cv.init.dir" description="iterate over *label.txt, call semil.processLabelFile">
		<for param="kernel.label.file" parallel="${parallel.folds}" threadCount="${kernel.threads}">
			<fileset dir="${kernel.data}" includes="*label.txt" />
			<sequential>
				<antcall target="semil.processLabelFile">
					<param name="kernel.label.file" value="@{kernel.label.file}" />
				</antcall>
			</sequential>
		</for>
	</target>
	<target name="semil.processLabelFile" depends="cv.init.dir" description="iterate over kernel.distFiles, call semil.iter.evalLines">
		<property name="kernel.label.file" value="${kernel.data}/label1_run1_fold1_label.txt"/>
		<basename file="${kernel.label.file}" property="kernel.label.filename" />
		<basename file="${kernel.label.filename}" property="kernel.label.basename" suffix=".txt" />
		<!-- load properties kernel.distFiles and kernel.evalLines defined -->
		<property file="${kernel.data}/${kernel.label.basename}.properties" />
		<property name="kernel.label.dir" value="${cv.kernel.tmpdir}-${kernel.label.basename}" />
		<echo>kernel.label.dir ${kernel.label.dir}</echo>
		<mkdir dir="${kernel.label.dir}" />
		<!-- copy distance files to working directory -->
		<copy todir="${kernel.label.dir}">
			<fileset dir="${kernel.data}" includes="${kernel.distFiles}" />
			<fileset dir="${kernel.data}" includes="${kernel.label.filename}" />
		</copy>
		<!-- iterate over distance files -->
		<for list="${kernel.distFiles}" param="kernel.dist.file">
			<sequential>
				<antcall target="semil.iter.evalLines">
					<param name="kernel.dist.file" value="@{kernel.dist.file}"/>
				</antcall>
			</sequential>
		</for>
		<!-- copy results -->
		<mkdir dir="${kernel.data}/eval/${kernel.label.basename}"/>
		<copy todir="${kernel.data}/eval/${kernel.label.basename}">
			<fileset dir="${kernel.label.dir}" includes="*.output"/>
		</copy>
		<!-- store semil options -->
		<echoproperties destfile="${kernel.data}/eval/${kernel.label.basename}/options.properties">
			<propertyset>
				<propertyref prefix="kernel." />
			</propertyset>
		</echoproperties>
		<!-- delete unneeded files -->
		<delete dir="${kernel.label.dir}" quiet="yes"/>
	</target>
	
	<target name="semil.iter.evalLines" description="iterate over kernel.evalLines, call semil.eval.label">
		<for list="${kernel.evalLines}" param="kernel.line">
			<sequential>
				<antcall target="semil.eval.label">
					<param name="kernel.line" value="@{kernel.line}"/>
				</antcall>
			</sequential>
		</for>
	</target>
	
	<target name="semil.eval.label" description="evaluate semil">
		<exec executable="${semil.bin}/Semil" dir="${kernel.label.dir}">
			<arg line="${kernel.line} ${kernel.dist.file} ${kernel.label.filename}" />
		</exec>
	</target>
	<target name="semil.storeResults" depends="cv.init.dir" description="store results in db, cleanup temp dirs">
		<antcall target="eval.store.db">
			<param name="kernel.workdir" value="${kernel.data}/eval" />
		</antcall>
		<mkdir dir="${kernel.data}/eval" />
		<zip destfile="${kernel.data}/eval.zip" update="no">
			<fileset dir="${kernel.data}/eval" />
		</zip>
		<delete quiet="yes" includeemptydirs="yes" dir="${kernel.data}/eval" />
	</target>


	<target name="eval.store.options" description="store options">
		<!-- store libsvm options -->
		<echoproperties destfile="${kernel.workdir}/${kernel.outdir}/options.properties">
			<propertyset>
				<propertyref prefix="kernel." />
			</propertyset>
		</echoproperties>
	</target>
	<target name="eval.store.db" description="store results in db" depends="cv.init.dir">
		<echo>kernel.workdir ${kernel.workdir}</echo>
		<java classname="ytex.kernel.ClassifierEvaluationImporter" classpathref="${kernel.cp}" fork="yes" dir="${kernel.data}" failOnError="yes">
			<arg value="-dir" />
			<arg value="${kernel.workdir}" />
			<arg value="-type" />
			<arg value="${kernel.algo}" />
			<jvmarg value="${log4j.arg}" />
			<jvmarg value="${java.log.arg}" />
		</java>
	</target>
</project>
